#pragma once

#include "CoreMinimal.h"
#include "Templates/SubclassOf.h"
#include "NameSelect.h"

//++CK
#include "Subsystem/BlueprintTask_Subsystem.h"
//--CK

#include "Blueprint/BlueprintExtension.h"
#include "StructUtils/InstancedStruct.h"
#include "Subsystem/BlueprintTaskTrackerSubsystem.h"
#include "UObject/Object.h"

#include "Btf_TaskForge.generated.h"

#if WITH_EDITOR
class UBNTNodeDecorator;
DECLARE_DELEGATE_OneParam(FOnPostPropertyChanged, FPropertyChangedEvent);
#endif

class UWorld;

USTRUCT(BlueprintType)
struct FCustomOutputPin
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString PinName;

	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	FString Tooltip;
};



USTRUCT(BlueprintType)
struct FCustomOutputPinData
{
	GENERATED_BODY()
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FCustomPinDelegate, FName, PinName, TInstancedStruct<FCustomOutputPinData>, Data);

/** BlueprintTaskTemplate */
UCLASS(Abstract, Blueprintable, BlueprintType, EditInlineNew)
class BLUEPRINTTASKFORGE_API UBlueprintTaskTemplate : public UBlueprintExtension
{
    GENERATED_BODY()
public:
    UBlueprintTaskTemplate(const FObjectInitializer& ObjectInitializer);

	UPROPERTY(BlueprintAssignable)
	FCustomPinDelegate OnCustomPinTriggered;

	UFUNCTION(
		BlueprintCallable,
		Category = "BlueprintTaskTemplate",
		meta =
			(DisplayName = "BlueprintTaskTemplate",
			 DefaultToSelf = "Outer",
			 BlueprintInternalUseOnly = "TRUE",
			 DeterminesOutputType = "Class",
			 Keywords = "BP Blueprint Task Template"))
	static UBlueprintTaskTemplate* BlueprintTaskTemplate(UObject* Outer, TSubclassOf<UBlueprintTaskTemplate> Class, FString NodeGuidStr);

	/**Returns the task template that is attached to the @Outer's blueprint.*/
	static UBlueprintTaskTemplate* GetTaskTemplateByNodeGUID(UObject* Outer, FString NodeGUID);

    UFUNCTION(BlueprintCallable, Category = "BlueprintTaskTemplate", meta = (DisplayName = "Activate", ExposeAutoCall = "true"))
//++CK
	void Activate()
	{
		if (const auto World = GetWorld();
			IsValid(World))
		{
			UUtils_BlueprintTask_Subsystem_UE::Request_TrackTask(World, this);
		}

		//++V
		#if !UE_BUILD_SHIPPING
		UBlueprintTaskTrackerSubsystem* TrackerSubsystem = GEngine->GetEngineSubsystem<UBlueprintTaskTrackerSubsystem>();
		if(TrackerSubsystem)
		{
			TrackerSubsystem->AddTask(this);
		}
		#endif
		//--V

		Activate_Internal();
	}
//--CK

//++CK
	UFUNCTION(BlueprintCallable, Category = "BlueprintTaskTemplate", meta = (DisplayName = "Deactivate", ExposeAutoCall = "false"))
	void Deactivate()
	{
		QUICK_SCOPE_CYCLE_COUNTER(TaskNode_Deactivate)

		//++V
		if(!IsActive)
		{
			return;
		}
		//--V

		for (const auto& Task : _TasksToDeactivateOnDeactivate)
		{
			if (Task.IsValid())
			{
				Task->Deactivate();
			}
		}

		if (const auto World = GetWorld();
			IsValid(World))
		{
			UUtils_BlueprintTask_Subsystem_UE::Request_UntrackTask(World, this);
		}

		//++V
		#if !UE_BUILD_SHIPPING
		UBlueprintTaskTrackerSubsystem* TrackerSubsystem = GEngine->GetEngineSubsystem<UBlueprintTaskTrackerSubsystem>();
		if(TrackerSubsystem)
		{
			TrackerSubsystem->RemoveTask(this);
		}
		#endif
		//--V

		Deactivate_Internal();
	}

    UFUNCTION(BlueprintCallable,
              Category = "BlueprintTaskTemplate",
              DisplayName = "[BlueprintNodeTemp] Add Task To Deactivate On  Deactivate",
              meta = (CompactNodeTitle="TaskToDeactivate_OnDeactivate", HideSelfPin = true, Keywords = "Register, Track"))
    void
    DoRequest_AddTaskToDeactivateOnDeactivate(
        class UBlueprintTaskTemplate* InTask);
//--CK

	virtual UWorld* GetWorld() const override
	{
		//++V
		return IsTemplate() ? nullptr : GetOuter() ? GetOuter()->GetWorld() : nullptr;
		//--V
	}

//++CK
    virtual void OnDestroy();
//--CK

    virtual void Serialize(FArchive& Ar) override;

//++V

	/**Gets all objects that have @Object assigned as their outer
	 * and recursively deactivates all tasks it finds.
	 * This includes nested objects, so for example; if @Object is
	 * an actor and its actor components have a task active and the
	 * component is its outer, this will also deactivate those tasks. */
	UFUNCTION(Category = "BlueprintTaskTemplate", BlueprintCallable, meta = (DefaultToSelf = "Object"))
	static void DeactivateAllTasksRelatedToObject(UObject* Object);

#if WITH_EDITORONLY_DATA
	UPROPERTY(Category = "Decorator", EditDefaultsOnly)
	TSubclassOf<UBNTNodeDecorator> Decorator = nullptr;
#endif

	/**Triggers a output pin that was generated by @GetCustomOutputPins.
	 * This does NOT trigger the other output pins that are generated
	 * by delegates on the node. */
	UFUNCTION(Category = "BlueprintTaskTemplate", BlueprintCallable)
	virtual void TriggerCustomOutputPin(UPARAM(Meta=(GetOptions = "GetCustomOutputPinNames")) FName OutputPin, TInstancedStruct<FCustomOutputPinData> Data);

	/**Each index from this function will generate a custom output pin
	 * on the node, which can then be triggered by calling @TriggerCustomOutputPin */
	UFUNCTION(BlueprintNativeEvent, Category = "BlueprintTaskTemplate")
	TArray<FCustomOutputPin> GetCustomOutputPins();

	/**Called when the parent blueprint this node is inside is compiled.
	 * If any errors are returned, the blueprint will not compile
	 * and report each error in the output log. */
	UFUNCTION(BlueprintNativeEvent, Category = "Editor", meta = (DevelopmentOnly, DisplayName = "Validate Node During Compilation (Editor Only)"))
	TArray<FString> ValidateNodeDuringCompilation();

	/**If returned true, the title color will adopt the returned @Color*/
	UFUNCTION(BlueprintNativeEvent, Category = "Editor", meta = (DevelopmentOnly))
	bool GetNodeTitleColor(FLinearColor& Color);

	/**Returns whether this instance is an extension
	 * attached to the blueprint.
	 * This is NOT the CDO, this is NOT the runtime instance.
	 * If true, this instance is an instance that is attached
	 * to the blueprint the node is inside. */
	UFUNCTION(Category = "BlueprintTaskTemplate", BlueprintCallable, BlueprintPure)
	bool IsExtension() const;

	/**For each element returned by this, the node will generate a output
	 * pin that can be triggered by calling @TriggerCustomOutputPin */
	UFUNCTION(Category = "BlueprintTaskTemplate", BlueprintCallable)
	TArray<FName> GetCustomOutputPinNames();
//--V

protected:
	UFUNCTION(BlueprintImplementableEvent, Category = "BlueprintTaskTemplate", meta = (DisplayName = "Activate"))
	void Activate_BP();
	virtual void Activate_Internal()
	{
		QUICK_SCOPE_CYCLE_COUNTER(TaskNode_Activate_Internal)
		//++CK
		if (IsBeingDestroyed)
		{ return; }

        if (IsValid(GetOuter()))
//--CK
        {
            IsActive = true;
            Activate_BP();
        }
    }

//++CK
    UFUNCTION(BlueprintImplementableEvent, Category = "BlueprintTaskTemplate", meta = (DisplayName = "Deactivate"))
    void Deactivate_BP();
    virtual void Deactivate_Internal();

	// Short summary of node's content - displayed over node as NodeInfoPopup
	UFUNCTION(BlueprintNativeEvent, Category = "BlueprintTaskTemplate", meta = (DisplayName = "Get Node Description"))
	FString Get_NodeDescription() const;

	// Information displayed while node is working - displayed over node as NodeInfoPopup
	UFUNCTION(BlueprintNativeEvent, Category = "BlueprintTaskTemplate", meta = (DisplayName = "Get Status String"))
	FString Get_StatusString() const;

	UFUNCTION(BlueprintNativeEvent, Category = "BlueprintTaskTemplate", meta = (DisplayName = "Get Status Background Color"))
	bool Get_StatusBackgroundColor(FLinearColor& OutColor) const;
//--CK

private:

//++CK
    UPROPERTY(Transient)
    bool IsBeingDestroyed = false;

    UPROPERTY(Transient)
    bool IsActive = false;

public:

	//++V
	/**These three options don't seem to ever be used for runtime logic.
	 * Think this safely can be wrapped with #if WITH_EDITORONLY_DATA
	 * to reduce tasks size 36 bytes. Tiny optimization though */
	//--V

#if WITH_EDITORONLY_DATA

	UPROPERTY(EditDefaultsOnly, Category = "DisplayOptions")
	FName Category = NAME_None;

	UPROPERTY(EditDefaultsOnly, Category = "DisplayOptions", meta = (MultiLine = true))
	FName Tooltip = NAME_None;

	UPROPERTY(EditDefaultsOnly, Category = "DisplayOptions")
	FName MenuDisplayName = NAME_None;

#endif

//--CK

#if WITH_EDITOR
public:
    // force refresh all for old/new in-editor params/functions etc
    void RefreshCollected();
    virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;

//++CK
	auto
	Get_IsActive() const -> bool;
//--CK

protected:
    static void CollectSpawnParam(const UClass* InClass, TSet<FName>& Out);
    static void CollectFunctions(const UClass* InClass, TSet<FName>& Out);
    static void CollectDelegates(const UClass* InClass, TSet<FName>& Out);
    static void CleanInvalidParams(TArray<FNameSelect>& Arr, const TSet<FName>& ArrRef);

#endif // WITH_EDITOR

#if WITH_EDITORONLY_DATA
public:
    UPROPERTY(VisibleDefaultsOnly, Category = "ExposeOptions")
    TSet<FName> AllDelegates;
    UPROPERTY(VisibleDefaultsOnly, Category = "ExposeOptions")
    TSet<FName> AllFunctions;
    UPROPERTY(VisibleDefaultsOnly, Category = "ExposeOptions")
    TSet<FName> AllFunctionsExec;
    UPROPERTY(VisibleDefaultsOnly, Category = "ExposeOptions")
    TSet<FName> AllParam;

	UPROPERTY(EditDefaultsOnly, Category = "ExposeOptions")
	TArray<FNameSelect> SpawnParam;
	UPROPERTY(EditDefaultsOnly, Category = "ExposeOptions")
	TArray<FNameSelect> AutoCallFunction;
	UPROPERTY(EditDefaultsOnly, Category = "ExposeOptions")
	TArray<FNameSelect> ExecFunction;
	UPROPERTY(EditDefaultsOnly, Category = "ExposeOptions")
	TArray<FNameSelect> InDelegate;
	UPROPERTY(EditDefaultsOnly, Category = "ExposeOptions")
	TArray<FNameSelect> OutDelegate;

	/**If filled, this node will only be permitted to be placed into
	 * these classes. This is mostly used for nodes that are
	 * limited to specific regions of code, for example
	 * quest designers and dialogue being limited to specific graphs. */
	UPROPERTY(EditDefaultsOnly, Category = "Developer Settings")
	TArray<TSoftClassPtr<UObject>> ClassLimitations;

	FOnPostPropertyChanged OnPostPropertyChanged;
	//--V

#endif

//++CK
private:
    TArray<TWeakObjectPtr<UBlueprintTaskTemplate>> _TasksToDeactivateOnDeactivate;
//--CK
};

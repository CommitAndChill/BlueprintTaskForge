#pragma once

#include "CoreMinimal.h"
#include "Templates/SubclassOf.h"
#include "BtfNameSelect.h"

#include "Blueprint/BlueprintExtension.h"
#include "StructUtils/InstancedStruct.h"
#include "UObject/Object.h"

#include "BtfTaskForge.generated.h"

#if WITH_EDITOR
class UBtf_NodeDecorator;
DECLARE_DELEGATE_OneParam(FOnPostPropertyChanged, FPropertyChangedEvent);
#endif

class UWorld;

USTRUCT(BlueprintType)
struct FCustomOutputPin
{
    GENERATED_BODY()

    UPROPERTY(BlueprintReadWrite, EditAnywhere)
    FString PinName;

    UPROPERTY(BlueprintReadWrite, EditAnywhere)
    FString Tooltip;
};

USTRUCT(BlueprintType)
struct FCustomOutputPinData
{
    GENERATED_BODY()
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FCustomPinDelegate, FName, PinName, TInstancedStruct<FCustomOutputPinData>, Data);

/** BlueprintTaskForge */
UCLASS(Abstract, Blueprintable, BlueprintType, EditInlineNew)
class BLUEPRINTTASKFORGE_API UBtf_TaskForge : public UBlueprintExtension
{
    GENERATED_BODY()
public:
    UBtf_TaskForge(const FObjectInitializer& ObjectInitializer);

    UPROPERTY(BlueprintAssignable)
    FCustomPinDelegate OnCustomPinTriggered;

    UFUNCTION(
        BlueprintCallable,
        Category = "BlueprintTaskForge",
        meta =
            (DisplayName = "BlueprintTaskForge",
             DefaultToSelf = "Outer",
             BlueprintInternalUseOnly = "TRUE",
             DeterminesOutputType = "Class",
             Keywords = "BP Blueprint Task Forge"))
    static UBtf_TaskForge* BlueprintTaskForge(UObject* Outer, TSubclassOf<UBtf_TaskForge> Class, FString NodeGuidStr);

    /**Returns the task template that is attached to the @Outer's blueprint.*/
    static UBtf_TaskForge* GetTaskByNodeGUID(UObject* Outer, FString NodeGUID);

    UFUNCTION(BlueprintCallable, Category = "BlueprintTaskForge", meta = (DisplayName = "Activate", ExposeAutoCall = "true"))
    void Activate();

    UFUNCTION(BlueprintCallable, Category = "BlueprintTaskForge", meta = (DisplayName = "Deactivate", ExposeAutoCall = "false"))
    void Deactivate();

    virtual UWorld* GetWorld() const override
    {
        //++V
        return IsTemplate() ? nullptr : GetOuter() ? GetOuter()->GetWorld() : nullptr;
        //--V
    }

//++CK
    virtual void OnDestroy();
//--CK

    virtual void Serialize(FArchive& Ar) override;

//++V

    /**Gets all objects that have @Object assigned as their outer
     * and recursively deactivates all tasks it finds.
     * This includes nested objects, so for example; if @Object is
     * an actor and its actor components have a task active and the
     * component is its outer, this will also deactivate those tasks. */
    UFUNCTION(Category = "BlueprintTaskForge", BlueprintCallable, meta = (DefaultToSelf = "Object"))
    static void DeactivateAllTasksRelatedToObject(UObject* Object);

#if WITH_EDITORONLY_DATA
    UPROPERTY(Category = "Decorator", EditDefaultsOnly)
    TSubclassOf<UBtf_NodeDecorator> Decorator = nullptr;
#endif

    /**Triggers a output pin that was generated by @GetCustomOutputPins.
     * This does NOT trigger the other output pins that are generated
     * by delegates on the node. */
    UFUNCTION(Category = "BlueprintTaskForge", BlueprintCallable)
    virtual void TriggerCustomOutputPin(UPARAM(Meta=(GetOptions = "GetCustomOutputPinNames")) FName OutputPin, TInstancedStruct<FCustomOutputPinData> Data);

    /**Each index from this function will generate a custom output pin
     * on the node, which can then be triggered by calling @TriggerCustomOutputPin */
    UFUNCTION(BlueprintNativeEvent, Category = "BlueprintTaskForge")
    TArray<FCustomOutputPin> GetCustomOutputPins();

    /**Called when the parent blueprint this node is inside is compiled.
     * If any errors are returned, the blueprint will not compile
     * and report each error in the output log. */
    UFUNCTION(BlueprintNativeEvent, Category = "Editor", meta = (DevelopmentOnly, DisplayName = "Validate Node During Compilation (Editor Only)"))
    TArray<FString> ValidateNodeDuringCompilation();

    /**If returned true, the title color will adopt the returned @Color*/
    UFUNCTION(BlueprintNativeEvent, Category = "Editor", meta = (DevelopmentOnly))
    bool GetNodeTitleColor(FLinearColor& Color);

    /**Returns whether this instance is an extension
     * attached to the blueprint.
     * This is NOT the CDO, this is NOT the runtime instance.
     * If true, this instance is an instance that is attached
     * to the blueprint the node is inside. */
    UFUNCTION(Category = "BlueprintTaskForge", BlueprintCallable, BlueprintPure)
    bool IsExtension() const;

    /**For each element returned by this, the node will generate a output
     * pin that can be triggered by calling @TriggerCustomOutputPin */
    UFUNCTION(Category = "BlueprintTaskForge", BlueprintCallable)
    TArray<FName> GetCustomOutputPinNames();
//--V

protected:
    UFUNCTION(BlueprintImplementableEvent, Category = "BlueprintTaskForge", meta = (DisplayName = "Activate"))
    void Activate_BP();
    virtual void Activate_Internal()
    {
        QUICK_SCOPE_CYCLE_COUNTER(TaskNode_Activate_Internal)
        //++CK
        if (IsBeingDestroyed)
        { return; }

        if (IsValid(GetOuter()))
//--CK
        {
//++V
            SetupAutomaticCleanup();
//--V 
            
            IsActive = true;
            Activate_BP();
        }
    }
    
//++V
    
    /**Called on @Activate. Will do one of two things:
     * 1. If the outer is an actor, bind to the Destroyed
     * event and when triggered, automatically call Deactivate
     * 2. If the outer is another task, add this task
     * to that task's @_TasksToDeactivateOnDeactivate array,
     * so if the owning task is deactivated, this will
     * also deactivate.
     * 
     * This is virtual for those projects that might already
     * have some kind of project-wide core parent, like a
     * widget that has a delegate for when it's removed
     * from its parent.
     *
     * Technically, we can bind to an actor component
     * but only on the Deactivate event. There is no bindable
     * Destroyed event. I don't like the idea of binding
     * to the Deactivate event, since there are many scenarios
     * where you'd deactivate a component but don't want
     * to end the component's tasks */
    virtual void SetupAutomaticCleanup();

    UFUNCTION()
    void OnActorOuterDestroyed(AActor* Actor)
    {
        Deactivate();
    }
//--V

    //++CK
    UFUNCTION(BlueprintImplementableEvent, Category = "BlueprintTaskForge", meta = (DisplayName = "Deactivate"))
    void Deactivate_BP();
    virtual void Deactivate_Internal();

    // Short summary of node's content - displayed over node as NodeInfoPopup
    UFUNCTION(BlueprintNativeEvent, Category = "BlueprintTaskForge", meta = (DisplayName = "Get Node Description"))
    FString Get_NodeDescription() const;

    // Information displayed while node is working - displayed over node as NodeInfoPopup
    UFUNCTION(BlueprintNativeEvent, Category = "BlueprintTaskForge", meta = (DisplayName = "Get Status String"))
    FString Get_StatusString() const;

    UFUNCTION(BlueprintNativeEvent, Category = "BlueprintTaskForge", meta = (DisplayName = "Get Status Background Color"))
    bool Get_StatusBackgroundColor(FLinearColor& OutColor) const;
//--CK

private:

//++CK
    UPROPERTY(Transient)
    bool IsBeingDestroyed = false;

    UPROPERTY(Transient)
    bool IsActive = false;

public:

    //++V
    /**These three options don't seem to ever be used for runtime logic.
     * Think this safely can be wrapped with #if WITH_EDITORONLY_DATA
     * to reduce tasks size 36 bytes. Tiny optimization though */
    //--V

#if WITH_EDITORONLY_DATA

    UPROPERTY(EditDefaultsOnly, Category = "DisplayOptions")
    FName Category = NAME_None;

    UPROPERTY(EditDefaultsOnly, Category = "DisplayOptions", meta = (MultiLine = true))
    FName Tooltip = NAME_None;

    UPROPERTY(EditDefaultsOnly, Category = "DisplayOptions")
    FName MenuDisplayName = NAME_None;

#endif

//--CK

#if WITH_EDITOR
public:
    // force refresh all for old/new in-editor params/functions etc
    void RefreshCollected();
    virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;

//++CK
    auto
    Get_IsActive() const -> bool;
//--CK

protected:
    static void CollectSpawnParam(const UClass* InClass, TSet<FName>& Out);
    static void CollectFunctions(const UClass* InClass, TSet<FName>& Out);
    static void CollectDelegates(const UClass* InClass, TSet<FName>& Out);
    static void CleanInvalidParams(TArray<FBtf_NameSelect>& Arr, const TSet<FName>& ArrRef);

#endif // WITH_EDITOR

#if WITH_EDITORONLY_DATA
public:
    UPROPERTY(VisibleDefaultsOnly, Category = "ExposeOptions")
    TSet<FName> AllDelegates;
    UPROPERTY(VisibleDefaultsOnly, Category = "ExposeOptions")
    TSet<FName> AllFunctions;
    UPROPERTY(VisibleDefaultsOnly, Category = "ExposeOptions")
    TSet<FName> AllFunctionsExec;
    UPROPERTY(VisibleDefaultsOnly, Category = "ExposeOptions")
    TSet<FName> AllParam;

    UPROPERTY(EditDefaultsOnly, Category = "ExposeOptions")
    TArray<FBtf_NameSelect> SpawnParam;
    UPROPERTY(EditDefaultsOnly, Category = "ExposeOptions")
    TArray<FBtf_NameSelect> AutoCallFunction;
    UPROPERTY(EditDefaultsOnly, Category = "ExposeOptions")
    TArray<FBtf_NameSelect> ExecFunction;
    UPROPERTY(EditDefaultsOnly, Category = "ExposeOptions")
    TArray<FBtf_NameSelect> InDelegate;
    UPROPERTY(EditDefaultsOnly, Category = "ExposeOptions")
    TArray<FBtf_NameSelect> OutDelegate;

    /**If filled, this node will only be permitted to be placed into
     * these classes. This is mostly used for nodes that are
     * limited to specific regions of code, for example
     * quest designers and dialogue being limited to specific graphs. */
    UPROPERTY(EditDefaultsOnly, Category = "Developer Settings")
    TArray<TSoftClassPtr<UObject>> ClassLimitations;

    FOnPostPropertyChanged OnPostPropertyChanged;
    //--V

#endif

    virtual void TrackTaskForAutomaticDeactivation(UBtf_TaskForge* Task)
    {
        if(Task && !_TasksToDeactivateOnDeactivate.Contains(Task))
        {
            _TasksToDeactivateOnDeactivate.Add(Task);
        }
    }

    virtual void UntrackTaskForAutomaticDeactivation(UBtf_TaskForge* Task)
    {
        if(Task && _TasksToDeactivateOnDeactivate.Contains(Task))
        {
            _TasksToDeactivateOnDeactivate.RemoveSingle(Task);
        }
    }

//++CK
private:
    TArray<TWeakObjectPtr<UBtf_TaskForge>> _TasksToDeactivateOnDeactivate;
//--CK
};
